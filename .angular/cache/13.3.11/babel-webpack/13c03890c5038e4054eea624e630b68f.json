{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { Directive, EventEmitter, Inject, Output, ContentChild, Input, Component, NgModule } from '@angular/core';\nimport * as i2 from '@angular/common';\nimport { DOCUMENT, CommonModule } from '@angular/common';\nimport { fromEvent } from 'rxjs';\nimport { takeUntil } from 'rxjs/operators';\nconst _c0 = [\"*\"];\nlet BitDraggingHandleDirective = /*#__PURE__*/(() => {\n  class BitDraggingHandleDirective {\n    constructor(elementRef) {\n      this.elementRef = elementRef;\n    }\n\n  }\n\n  BitDraggingHandleDirective.ɵfac = function BitDraggingHandleDirective_Factory(t) {\n    return new (t || BitDraggingHandleDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n  };\n\n  BitDraggingHandleDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BitDraggingHandleDirective,\n    selectors: [[\"\", \"dragginghandle\", \"\"]]\n  });\n  return BitDraggingHandleDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BitDraggingDirective = /*#__PURE__*/(() => {\n  class BitDraggingDirective {\n    constructor(elementRef, document) {\n      this.elementRef = elementRef;\n      this.document = document;\n      this.subscriptions = [];\n      this.Axis = new EventEmitter();\n      this.X = 0;\n      this.Y = 0;\n    }\n\n    ngAfterViewInit() {\n      var _a, _b;\n\n      this.draggingBoundaryElement = this.document.querySelector(this.boundaryQuery);\n\n      if (!this.draggingBoundaryElement) {\n        throw new Error(\"Couldn't find any element with query: \" + this.boundaryQuery);\n      } else {\n        this.element = this.elementRef.nativeElement;\n        this.handleElement = ((_b = (_a = this.handle) === null || _a === void 0 ? void 0 : _a.elementRef) === null || _b === void 0 ? void 0 : _b.nativeElement) || this.element;\n        this.initDrag();\n      }\n    }\n\n    initDrag() {\n      const dragStart$ = fromEvent(this.handleElement, \"mousedown\");\n      const dragEnd$ = fromEvent(this.document, \"mouseup\");\n      const drag$ = fromEvent(this.document, \"mousemove\").pipe(takeUntil(dragEnd$));\n      let initialX,\n          initialY,\n          currentX = this.X,\n          currentY = this.Y;\n      let dragSub;\n      const minBoundX = this.draggingBoundaryElement.offsetLeft;\n      const minBoundY = this.draggingBoundaryElement.offsetTop;\n      const maxBoundX = minBoundX + this.draggingBoundaryElement.offsetWidth - this.element.offsetWidth;\n      const maxBoundY = minBoundY + this.draggingBoundaryElement.offsetHeight - this.element.offsetHeight;\n      const dragStartSub = dragStart$.subscribe(event => {\n        initialX = event.clientX - currentX;\n        initialY = event.clientY - currentY;\n        this.element.classList.add(\"free-dragging\");\n        dragSub = drag$.subscribe(event => {\n          event.preventDefault();\n          const x = event.clientX - initialX;\n          const y = event.clientY - initialY;\n          currentX = Math.max(minBoundX, Math.min(x, maxBoundX));\n          currentY = Math.max(minBoundY, Math.min(y, maxBoundY));\n          this.Axis.emit({\n            X: currentX,\n            Y: currentY\n          });\n          this.element.style.transform = \"translate3d(\" + currentX + \"px, \" + currentY + \"px, 0)\";\n        });\n      });\n      const dragEndSub = dragEnd$.subscribe(() => {\n        initialX = currentX;\n        initialY = currentY;\n        this.element.classList.remove(\"free-dragging\");\n\n        if (dragSub) {\n          dragSub.unsubscribe();\n        }\n      });\n      this.subscriptions.push.apply(this.subscriptions, [dragStartSub, dragSub, dragEndSub]);\n    }\n\n    ngOnDestroy() {\n      this.subscriptions.forEach(s => s === null || s === void 0 ? void 0 : s.unsubscribe());\n    }\n\n  }\n\n  BitDraggingDirective.ɵfac = function BitDraggingDirective_Factory(t) {\n    return new (t || BitDraggingDirective)(i0.ɵɵdirectiveInject(i0.ElementRef), i0.ɵɵdirectiveInject(DOCUMENT));\n  };\n\n  BitDraggingDirective.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: BitDraggingDirective,\n    selectors: [[\"\", \"dragging\", \"\"]],\n    contentQueries: function BitDraggingDirective_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, BitDraggingHandleDirective, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.handle = _t.first);\n      }\n    },\n    inputs: {\n      boundaryQuery: \"boundaryQuery\",\n      X: \"X\",\n      Y: \"Y\"\n    },\n    outputs: {\n      Axis: \"Axis\"\n    }\n  });\n  return BitDraggingDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet DraggableComponent = /*#__PURE__*/(() => {\n  class DraggableComponent {\n    constructor() {\n      this.Transform = {\n        transform: 'translate3d(0px,0px,0)',\n        'z-index': 0\n      };\n      this.Boundry = \"body\";\n      this.X = 0;\n      this.Y = 0;\n      this.Z = 0;\n      this.Axis = new EventEmitter();\n    }\n\n    ngAfterViewInit() {\n      this.Transform.transform = `translate3d(${this.X + 'px'},${this.Y + 'px'},0)`;\n      this.Transform['z-index'] = this.Z;\n    }\n\n    GetAxispoint(event) {\n      this.Axis.emit(event);\n    }\n\n  }\n\n  DraggableComponent.ɵfac = function DraggableComponent_Factory(t) {\n    return new (t || DraggableComponent)();\n  };\n\n  DraggableComponent.ɵcmp = /* @__PURE__ */i0.ɵɵdefineComponent({\n    type: DraggableComponent,\n    selectors: [[\"Bit-draggable\"]],\n    inputs: {\n      Boundry: \"Boundry\",\n      X: \"X\",\n      Y: \"Y\",\n      Z: \"Z\"\n    },\n    outputs: {\n      Axis: \"Axis\"\n    },\n    ngContentSelectors: _c0,\n    decls: 2,\n    vars: 4,\n    consts: [[\"dragging\", \"\", \"draggable\", \"true\", 2, \"position\", \"absolute\", 3, \"X\", \"Y\", \"boundaryQuery\", \"ngStyle\", \"Axis\"]],\n    template: function DraggableComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵprojectionDef();\n        i0.ɵɵelementStart(0, \"div\", 0);\n        i0.ɵɵlistener(\"Axis\", function DraggableComponent_Template_div_Axis_0_listener($event) {\n          return ctx.GetAxispoint($event);\n        });\n        i0.ɵɵprojection(1);\n        i0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        i0.ɵɵproperty(\"X\", ctx.X)(\"Y\", ctx.Y)(\"boundaryQuery\", ctx.Boundry)(\"ngStyle\", ctx.Transform);\n      }\n    },\n    directives: [BitDraggingDirective, i2.NgStyle],\n    styles: [\"\"]\n  });\n  return DraggableComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet BitdraggableModule = /*#__PURE__*/(() => {\n  class BitdraggableModule {}\n\n  BitdraggableModule.ɵfac = function BitdraggableModule_Factory(t) {\n    return new (t || BitdraggableModule)();\n  };\n\n  BitdraggableModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: BitdraggableModule\n  });\n  BitdraggableModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    imports: [[CommonModule]]\n  });\n  return BitdraggableModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/*\r\n * Public API Surface of bitdraggable\r\n */\n\n/**\r\n * Generated bundle index. Do not edit.\r\n */\n\n\nexport { BitDraggingDirective, BitDraggingHandleDirective, BitdraggableModule, DraggableComponent }; //# sourceMappingURL=bitbeast-bitdraggable.mjs.map","map":null,"metadata":{},"sourceType":"module"}