{"ast":null,"code":"/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\n\nexport default class ContextWatchdog extends Watchdog {\n  /**\n   * The context watchdog class constructor.\n   *\n   * ```ts\n   * const watchdog = new ContextWatchdog( Context );\n   *\n   * await watchdog.create( contextConfiguration );\n   *\n   * await watchdog.add( item );\n   * ```\n   *\n   * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n   *\n   * @param Context The {@link module:core/context~Context} class.\n   * @param watchdogConfig The watchdog configuration.\n   */\n  constructor(Context, watchdogConfig = {}) {\n    super(watchdogConfig);\n    /**\n     * A map of internal watchdogs for added items.\n     */\n\n    this._watchdogs = new Map();\n    /**\n     * The current context instance.\n     */\n\n    this._context = null;\n    /**\n     * Context properties (nodes/references) that are gathered during the initial context creation\n     * and are used to distinguish the origin of an error.\n     */\n\n    this._contextProps = new Set();\n    /**\n     * An action queue, which is used to handle async functions queuing.\n     */\n\n    this._actionQueues = new ActionQueues();\n    this._watchdogConfig = watchdogConfig; // Default creator and destructor.\n\n    this._creator = contextConfig => Context.create(contextConfig);\n\n    this._destructor = context => context.destroy();\n\n    this._actionQueues.onEmpty(() => {\n      if (this.state === 'initializing') {\n        this.state = 'ready';\n\n        this._fire('stateChange');\n      }\n    });\n  }\n  /**\n   * Sets the function that is responsible for the context creation.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setCreator( config => Context.create( config ) );\n   * ```\n   */\n\n\n  setCreator(creator) {\n    this._creator = creator;\n  }\n  /**\n   * Sets the function that is responsible for the context destruction.\n   * Overrides the default destruction function, which destroys only the context instance.\n   * It expects a function that should return a promise (or `undefined`).\n   *\n   * ```ts\n   * watchdog.setDestructor( context => {\n   * \t// Do something before the context is destroyed.\n   *\n   * \treturn context\n   * \t\t.destroy()\n   * \t\t.then( () => {\n   * \t\t\t// Do something after the context is destroyed.\n   * \t\t} );\n   * } );\n   * ```\n   */\n\n\n  setDestructor(destructor) {\n    this._destructor = destructor;\n  }\n  /**\n   * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n   * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n   */\n\n\n  get context() {\n    return this._context;\n  }\n  /**\n   * Initializes the context watchdog. Once it is created, the watchdog takes care about\n   * recreating the context and the provided items, and starts the error handling mechanism.\n   *\n   * ```ts\n   * await watchdog.create( {\n   * \tplugins: []\n   * } );\n   * ```\n   *\n   * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n   */\n\n\n  create(contextConfig = {}) {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this._contextConfig = contextConfig;\n      return this._create();\n    });\n  }\n  /**\n   * Returns an item instance with the given `itemId`.\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * @param itemId The item ID.\n   * @returns The item instance or `undefined` if an item with a given ID has not been found.\n   */\n\n\n  getItem(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n\n    return watchdog._item;\n  }\n  /**\n   * Gets the state of the given item. See {@link #state} for a list of available states.\n   *\n   * ```ts\n   * const editor1State = watchdog.getItemState( 'editor1' );\n   * ```\n   *\n   * @param itemId Item ID.\n   * @returns The state of the item.\n   */\n\n\n  getItemState(itemId) {\n    const watchdog = this._getWatchdog(itemId);\n\n    return watchdog.state;\n  }\n  /**\n   * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n   *\n   * Items can be passed together as an array of objects:\n   *\n   * ```ts\n   * await watchdog.add( [ {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * } ] );\n   * ```\n   *\n   * Or one by one as objects:\n   *\n   * ```ts\n   * await watchdog.add( {\n   * \tid: 'editor1',\n   * \ttype: 'editor',\n   * \tsourceElementOrData: document.querySelector( '#editor' ),\n   * \tconfig: {\n   * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n   * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n   * \t},\n   * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n   * ] );\n   * ```\n   *\n   * Then an instance can be retrieved using the {@link #getItem} method:\n   *\n   * ```ts\n   * const editor1 = watchdog.getItem( 'editor1' );\n   * ```\n   *\n   * Note that this method can be called multiple times, but for performance reasons it is better\n   * to pass all items together.\n   *\n   * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n   */\n\n\n  add(itemConfigurationOrItemConfigurations) {\n    const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n    return Promise.all(itemConfigurations.map(item => {\n      return this._actionQueues.enqueue(item.id, () => {\n        if (this.state === 'destroyed') {\n          throw new Error('Cannot add items to destroyed watchdog.');\n        }\n\n        if (!this._context) {\n          throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n        }\n\n        let watchdog;\n\n        if (this._watchdogs.has(item.id)) {\n          throw new Error(`Item with the given id is already added: '${item.id}'.`);\n        }\n\n        if (item.type === 'editor') {\n          watchdog = new EditorWatchdog(null, this._watchdogConfig);\n          watchdog.setCreator(item.creator);\n\n          watchdog._setExcludedProperties(this._contextProps);\n\n          if (item.destructor) {\n            watchdog.setDestructor(item.destructor);\n          }\n\n          this._watchdogs.set(item.id, watchdog); // Enqueue the internal watchdog errors within the main queue.\n          // And propagate the internal `error` events as `itemError` event.\n\n\n          watchdog.on('error', (evt, {\n            error,\n            causesRestart\n          }) => {\n            this._fire('itemError', {\n              itemId: item.id,\n              error\n            }); // Do not enqueue the item restart action if the item will not restart.\n\n\n            if (!causesRestart) {\n              return;\n            }\n\n            this._actionQueues.enqueue(item.id, () => new Promise(res => {\n              const rethrowRestartEventOnce = () => {\n                watchdog.off('restart', rethrowRestartEventOnce);\n\n                this._fire('itemRestart', {\n                  itemId: item.id\n                });\n\n                res();\n              };\n\n              watchdog.on('restart', rethrowRestartEventOnce);\n            }));\n          });\n          return watchdog.create(item.sourceElementOrData, item.config, this._context);\n        } else {\n          throw new Error(`Not supported item type: '${item.type}'.`);\n        }\n      });\n    }));\n  }\n  /**\n   * Removes and destroys item(s) with given ID(s).\n   *\n   * ```ts\n   * await watchdog.remove( 'editor1' );\n   * ```\n   *\n   * Or\n   *\n   * ```ts\n   * await watchdog.remove( [ 'editor1', 'editor2' ] );\n   * ```\n   *\n   * @param itemIdOrItemIds Item ID or an array of item IDs.\n   */\n\n\n  remove(itemIdOrItemIds) {\n    const itemIds = toArray(itemIdOrItemIds);\n    return Promise.all(itemIds.map(itemId => {\n      return this._actionQueues.enqueue(itemId, () => {\n        const watchdog = this._getWatchdog(itemId);\n\n        this._watchdogs.delete(itemId);\n\n        return watchdog.destroy();\n      });\n    }));\n  }\n  /**\n   * Destroys the context watchdog and all added items.\n   * Once the context watchdog is destroyed, new items cannot be added.\n   *\n   * ```ts\n   * await watchdog.destroy();\n   * ```\n   */\n\n\n  destroy() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'destroyed';\n\n      this._fire('stateChange');\n\n      super.destroy();\n      return this._destroy();\n    });\n  }\n  /**\n   * Restarts the context watchdog.\n   */\n\n\n  _restart() {\n    return this._actionQueues.enqueue(mainQueueId, () => {\n      this.state = 'initializing';\n\n      this._fire('stateChange');\n\n      return this._destroy().catch(err => {\n        console.error('An error happened during destroying the context or items.', err);\n      }).then(() => this._create()).then(() => this._fire('restart'));\n    });\n  }\n  /**\n   * Initializes the context watchdog.\n   */\n\n\n  _create() {\n    return Promise.resolve().then(() => {\n      this._startErrorHandling();\n\n      return this._creator(this._contextConfig);\n    }).then(context => {\n      this._context = context;\n      this._contextProps = getSubNodes(this._context);\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => {\n        watchdog._setExcludedProperties(this._contextProps);\n\n        return watchdog.create(undefined, undefined, this._context);\n      }));\n    });\n  }\n  /**\n   * Destroys the context instance and all added items.\n   */\n\n\n  _destroy() {\n    return Promise.resolve().then(() => {\n      this._stopErrorHandling();\n\n      const context = this._context;\n      this._context = null;\n      this._contextProps = new Set();\n      return Promise.all(Array.from(this._watchdogs.values()).map(watchdog => watchdog.destroy())) // Context destructor destroys each editor.\n      .then(() => this._destructor(context));\n    });\n  }\n  /**\n   * Returns the watchdog for a given item ID.\n   *\n   * @param itemId Item ID.\n   */\n\n\n  _getWatchdog(itemId) {\n    const watchdog = this._watchdogs.get(itemId);\n\n    if (!watchdog) {\n      throw new Error(`Item with the given id was not registered: ${itemId}.`);\n    }\n\n    return watchdog;\n  }\n  /**\n   * Checks whether an error comes from the context instance and not from the item instances.\n   *\n   * @internal\n   */\n\n\n  _isErrorComingFromThisItem(error) {\n    for (const watchdog of this._watchdogs.values()) {\n      if (watchdog._isErrorComingFromThisItem(error)) {\n        return false;\n      }\n    }\n\n    return areConnectedThroughProperties(this._context, error.context);\n  }\n\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\n\nclass ActionQueues {\n  constructor() {\n    this._onEmptyCallbacks = [];\n    this._queues = new Map();\n    this._activeActions = 0;\n  }\n  /**\n   * Used to register callbacks that will be run when the queue becomes empty.\n   *\n   * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n   */\n\n\n  onEmpty(onEmptyCallback) {\n    this._onEmptyCallbacks.push(onEmptyCallback);\n  }\n  /**\n   * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n   *\n   * @param queueId The action queue ID.\n   * @param action A function that should be enqueued.\n   */\n\n\n  enqueue(queueId, action) {\n    const isMainAction = queueId === mainQueueId;\n    this._activeActions++;\n\n    if (!this._queues.get(queueId)) {\n      this._queues.set(queueId, Promise.resolve());\n    } // List all sources of actions that the current action needs to await for.\n    // For the main action wait for all other actions.\n    // For the item action wait only for the item queue and the main queue.\n\n\n    const awaitedActions = isMainAction ? Promise.all(this._queues.values()) : Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n    const queueWithAction = awaitedActions.then(action); // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n\n    const nonErrorQueue = queueWithAction.catch(() => {});\n\n    this._queues.set(queueId, nonErrorQueue);\n\n    return queueWithAction.finally(() => {\n      this._activeActions--;\n\n      if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n        this._onEmptyCallbacks.forEach(cb => cb());\n      }\n    });\n  }\n\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\n\n\nfunction toArray(elementOrArray) {\n  return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}","map":{"version":3,"sources":["C:/Users/Sunil/Desktop/Angular 13/ang13/node_modules/@ckeditor/ckeditor5-watchdog/src/contextwatchdog.js"],"names":["Watchdog","EditorWatchdog","areConnectedThroughProperties","getSubNodes","mainQueueId","Symbol","ContextWatchdog","constructor","Context","watchdogConfig","_watchdogs","Map","_context","_contextProps","Set","_actionQueues","ActionQueues","_watchdogConfig","_creator","contextConfig","create","_destructor","context","destroy","onEmpty","state","_fire","setCreator","creator","setDestructor","destructor","enqueue","_contextConfig","_create","getItem","itemId","watchdog","_getWatchdog","_item","getItemState","add","itemConfigurationOrItemConfigurations","itemConfigurations","toArray","Promise","all","map","item","id","Error","has","type","_setExcludedProperties","set","on","evt","error","causesRestart","res","rethrowRestartEventOnce","off","sourceElementOrData","config","remove","itemIdOrItemIds","itemIds","delete","_destroy","_restart","catch","err","console","then","resolve","_startErrorHandling","Array","from","values","undefined","_stopErrorHandling","get","_isErrorComingFromThisItem","_onEmptyCallbacks","_queues","_activeActions","onEmptyCallback","push","queueId","action","isMainAction","awaitedActions","queueWithAction","nonErrorQueue","finally","forEach","cb","elementOrArray","isArray"],"mappings":"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","sourcesContent":["/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license\n */\nimport Watchdog from './watchdog.js';\nimport EditorWatchdog from './editorwatchdog.js';\nimport areConnectedThroughProperties from './utils/areconnectedthroughproperties.js';\nimport getSubNodes from './utils/getsubnodes.js';\nconst mainQueueId = Symbol('MainQueueId');\n/**\n * A watchdog for the {@link module:core/context~Context} class.\n *\n * See the {@glink features/watchdog Watchdog feature guide} to learn the rationale behind it and\n * how to use it.\n */\nexport default class ContextWatchdog extends Watchdog {\n    /**\n     * The context watchdog class constructor.\n     *\n     * ```ts\n     * const watchdog = new ContextWatchdog( Context );\n     *\n     * await watchdog.create( contextConfiguration );\n     *\n     * await watchdog.add( item );\n     * ```\n     *\n     * See the {@glink features/watchdog Watchdog feature guide} to learn more how to use this feature.\n     *\n     * @param Context The {@link module:core/context~Context} class.\n     * @param watchdogConfig The watchdog configuration.\n     */\n    constructor(Context, watchdogConfig = {}) {\n        super(watchdogConfig);\n        /**\n         * A map of internal watchdogs for added items.\n         */\n        this._watchdogs = new Map();\n        /**\n         * The current context instance.\n         */\n        this._context = null;\n        /**\n         * Context properties (nodes/references) that are gathered during the initial context creation\n         * and are used to distinguish the origin of an error.\n         */\n        this._contextProps = new Set();\n        /**\n         * An action queue, which is used to handle async functions queuing.\n         */\n        this._actionQueues = new ActionQueues();\n        this._watchdogConfig = watchdogConfig;\n        // Default creator and destructor.\n        this._creator = contextConfig => Context.create(contextConfig);\n        this._destructor = context => context.destroy();\n        this._actionQueues.onEmpty(() => {\n            if (this.state === 'initializing') {\n                this.state = 'ready';\n                this._fire('stateChange');\n            }\n        });\n    }\n    /**\n     * Sets the function that is responsible for the context creation.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setCreator( config => Context.create( config ) );\n     * ```\n     */\n    setCreator(creator) {\n        this._creator = creator;\n    }\n    /**\n     * Sets the function that is responsible for the context destruction.\n     * Overrides the default destruction function, which destroys only the context instance.\n     * It expects a function that should return a promise (or `undefined`).\n     *\n     * ```ts\n     * watchdog.setDestructor( context => {\n     * \t// Do something before the context is destroyed.\n     *\n     * \treturn context\n     * \t\t.destroy()\n     * \t\t.then( () => {\n     * \t\t\t// Do something after the context is destroyed.\n     * \t\t} );\n     * } );\n     * ```\n     */\n    setDestructor(destructor) {\n        this._destructor = destructor;\n    }\n    /**\n     * The context instance. Keep in mind that this property might be changed when the context watchdog restarts,\n     * so do not keep this instance internally. Always operate on the `ContextWatchdog#context` property.\n     */\n    get context() {\n        return this._context;\n    }\n    /**\n     * Initializes the context watchdog. Once it is created, the watchdog takes care about\n     * recreating the context and the provided items, and starts the error handling mechanism.\n     *\n     * ```ts\n     * await watchdog.create( {\n     * \tplugins: []\n     * } );\n     * ```\n     *\n     * @param contextConfig The context configuration. See {@link module:core/context~Context}.\n     */\n    create(contextConfig = {}) {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this._contextConfig = contextConfig;\n            return this._create();\n        });\n    }\n    /**\n     * Returns an item instance with the given `itemId`.\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * @param itemId The item ID.\n     * @returns The item instance or `undefined` if an item with a given ID has not been found.\n     */\n    getItem(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog._item;\n    }\n    /**\n     * Gets the state of the given item. See {@link #state} for a list of available states.\n     *\n     * ```ts\n     * const editor1State = watchdog.getItemState( 'editor1' );\n     * ```\n     *\n     * @param itemId Item ID.\n     * @returns The state of the item.\n     */\n    getItemState(itemId) {\n        const watchdog = this._getWatchdog(itemId);\n        return watchdog.state;\n    }\n    /**\n     * Adds items to the watchdog. Once created, instances of these items will be available using the {@link #getItem} method.\n     *\n     * Items can be passed together as an array of objects:\n     *\n     * ```ts\n     * await watchdog.add( [ {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * } ] );\n     * ```\n     *\n     * Or one by one as objects:\n     *\n     * ```ts\n     * await watchdog.add( {\n     * \tid: 'editor1',\n     * \ttype: 'editor',\n     * \tsourceElementOrData: document.querySelector( '#editor' ),\n     * \tconfig: {\n     * \t\tplugins: [ Essentials, Paragraph, Bold, Italic ],\n     * \t\ttoolbar: [ 'bold', 'italic', 'alignment' ]\n     * \t},\n     * \tcreator: ( element, config ) => ClassicEditor.create( element, config )\n     * ] );\n     * ```\n     *\n     * Then an instance can be retrieved using the {@link #getItem} method:\n     *\n     * ```ts\n     * const editor1 = watchdog.getItem( 'editor1' );\n     * ```\n     *\n     * Note that this method can be called multiple times, but for performance reasons it is better\n     * to pass all items together.\n     *\n     * @param itemConfigurationOrItemConfigurations An item configuration object or an array of item configurations.\n     */\n    add(itemConfigurationOrItemConfigurations) {\n        const itemConfigurations = toArray(itemConfigurationOrItemConfigurations);\n        return Promise.all(itemConfigurations.map(item => {\n            return this._actionQueues.enqueue(item.id, () => {\n                if (this.state === 'destroyed') {\n                    throw new Error('Cannot add items to destroyed watchdog.');\n                }\n                if (!this._context) {\n                    throw new Error('Context was not created yet. You should call the `ContextWatchdog#create()` method first.');\n                }\n                let watchdog;\n                if (this._watchdogs.has(item.id)) {\n                    throw new Error(`Item with the given id is already added: '${item.id}'.`);\n                }\n                if (item.type === 'editor') {\n                    watchdog = new EditorWatchdog(null, this._watchdogConfig);\n                    watchdog.setCreator(item.creator);\n                    watchdog._setExcludedProperties(this._contextProps);\n                    if (item.destructor) {\n                        watchdog.setDestructor(item.destructor);\n                    }\n                    this._watchdogs.set(item.id, watchdog);\n                    // Enqueue the internal watchdog errors within the main queue.\n                    // And propagate the internal `error` events as `itemError` event.\n                    watchdog.on('error', (evt, { error, causesRestart }) => {\n                        this._fire('itemError', { itemId: item.id, error });\n                        // Do not enqueue the item restart action if the item will not restart.\n                        if (!causesRestart) {\n                            return;\n                        }\n                        this._actionQueues.enqueue(item.id, () => new Promise(res => {\n                            const rethrowRestartEventOnce = () => {\n                                watchdog.off('restart', rethrowRestartEventOnce);\n                                this._fire('itemRestart', { itemId: item.id });\n                                res();\n                            };\n                            watchdog.on('restart', rethrowRestartEventOnce);\n                        }));\n                    });\n                    return watchdog.create(item.sourceElementOrData, item.config, this._context);\n                }\n                else {\n                    throw new Error(`Not supported item type: '${item.type}'.`);\n                }\n            });\n        }));\n    }\n    /**\n     * Removes and destroys item(s) with given ID(s).\n     *\n     * ```ts\n     * await watchdog.remove( 'editor1' );\n     * ```\n     *\n     * Or\n     *\n     * ```ts\n     * await watchdog.remove( [ 'editor1', 'editor2' ] );\n     * ```\n     *\n     * @param itemIdOrItemIds Item ID or an array of item IDs.\n     */\n    remove(itemIdOrItemIds) {\n        const itemIds = toArray(itemIdOrItemIds);\n        return Promise.all(itemIds.map(itemId => {\n            return this._actionQueues.enqueue(itemId, () => {\n                const watchdog = this._getWatchdog(itemId);\n                this._watchdogs.delete(itemId);\n                return watchdog.destroy();\n            });\n        }));\n    }\n    /**\n     * Destroys the context watchdog and all added items.\n     * Once the context watchdog is destroyed, new items cannot be added.\n     *\n     * ```ts\n     * await watchdog.destroy();\n     * ```\n     */\n    destroy() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'destroyed';\n            this._fire('stateChange');\n            super.destroy();\n            return this._destroy();\n        });\n    }\n    /**\n     * Restarts the context watchdog.\n     */\n    _restart() {\n        return this._actionQueues.enqueue(mainQueueId, () => {\n            this.state = 'initializing';\n            this._fire('stateChange');\n            return this._destroy()\n                .catch(err => {\n                console.error('An error happened during destroying the context or items.', err);\n            })\n                .then(() => this._create())\n                .then(() => this._fire('restart'));\n        });\n    }\n    /**\n     * Initializes the context watchdog.\n     */\n    _create() {\n        return Promise.resolve()\n            .then(() => {\n            this._startErrorHandling();\n            return this._creator(this._contextConfig);\n        })\n            .then(context => {\n            this._context = context;\n            this._contextProps = getSubNodes(this._context);\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => {\n                watchdog._setExcludedProperties(this._contextProps);\n                return watchdog.create(undefined, undefined, this._context);\n            }));\n        });\n    }\n    /**\n     * Destroys the context instance and all added items.\n     */\n    _destroy() {\n        return Promise.resolve()\n            .then(() => {\n            this._stopErrorHandling();\n            const context = this._context;\n            this._context = null;\n            this._contextProps = new Set();\n            return Promise.all(Array.from(this._watchdogs.values())\n                .map(watchdog => watchdog.destroy()))\n                // Context destructor destroys each editor.\n                .then(() => this._destructor(context));\n        });\n    }\n    /**\n     * Returns the watchdog for a given item ID.\n     *\n     * @param itemId Item ID.\n     */\n    _getWatchdog(itemId) {\n        const watchdog = this._watchdogs.get(itemId);\n        if (!watchdog) {\n            throw new Error(`Item with the given id was not registered: ${itemId}.`);\n        }\n        return watchdog;\n    }\n    /**\n     * Checks whether an error comes from the context instance and not from the item instances.\n     *\n     * @internal\n     */\n    _isErrorComingFromThisItem(error) {\n        for (const watchdog of this._watchdogs.values()) {\n            if (watchdog._isErrorComingFromThisItem(error)) {\n                return false;\n            }\n        }\n        return areConnectedThroughProperties(this._context, error.context);\n    }\n}\n/**\n * Manager of action queues that allows queuing async functions.\n */\nclass ActionQueues {\n    constructor() {\n        this._onEmptyCallbacks = [];\n        this._queues = new Map();\n        this._activeActions = 0;\n    }\n    /**\n     * Used to register callbacks that will be run when the queue becomes empty.\n     *\n     * @param onEmptyCallback A callback that will be run whenever the queue becomes empty.\n     */\n    onEmpty(onEmptyCallback) {\n        this._onEmptyCallbacks.push(onEmptyCallback);\n    }\n    /**\n     * It adds asynchronous actions (functions) to the proper queue and runs them one by one.\n     *\n     * @param queueId The action queue ID.\n     * @param action A function that should be enqueued.\n     */\n    enqueue(queueId, action) {\n        const isMainAction = queueId === mainQueueId;\n        this._activeActions++;\n        if (!this._queues.get(queueId)) {\n            this._queues.set(queueId, Promise.resolve());\n        }\n        // List all sources of actions that the current action needs to await for.\n        // For the main action wait for all other actions.\n        // For the item action wait only for the item queue and the main queue.\n        const awaitedActions = isMainAction ?\n            Promise.all(this._queues.values()) :\n            Promise.all([this._queues.get(mainQueueId), this._queues.get(queueId)]);\n        const queueWithAction = awaitedActions.then(action);\n        // Catch all errors in the main queue to stack promises even if an error occurred in the past.\n        const nonErrorQueue = queueWithAction.catch(() => { });\n        this._queues.set(queueId, nonErrorQueue);\n        return queueWithAction.finally(() => {\n            this._activeActions--;\n            if (this._queues.get(queueId) === nonErrorQueue && this._activeActions === 0) {\n                this._onEmptyCallbacks.forEach(cb => cb());\n            }\n        });\n    }\n}\n/**\n * Transforms any value to an array. If the provided value is already an array, it is returned unchanged.\n *\n * @param elementOrArray The value to transform to an array.\n * @returns An array created from data.\n */\nfunction toArray(elementOrArray) {\n    return Array.isArray(elementOrArray) ? elementOrArray : [elementOrArray];\n}\n"]},"metadata":{},"sourceType":"module"}